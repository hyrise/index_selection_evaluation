from ..selection_algorithm import SelectionAlgorithm
from ..index import Index
import logging


# cost_estimation: 'whatif' or 'acutal_runtimes'
# Index combination budget in MB
DEFAULT_PARAMETERS = {
    'cost_estimation': 'whatif',
    'budget': 10
}


class EPICAlgorithm(SelectionAlgorithm):
    def __init__(self, database_connector, parameters={}):
        SelectionAlgorithm.__init__(self, database_connector, parameters,
                                    DEFAULT_PARAMETERS)
        # MB to Bytes
        self.budget = self.parameters['budget'] * 1000000
        self.workload = None

    def _calculate_best_indexes(self, workload):
        logging.info('Calculating best indexes EPIC')
        self.workload = workload
        single_attribute_index_candidates = self.potential_indexes(self.workload)

        # Current index combination
        index_combination = []
        index_combination_size = 0
        # Best index combination during evaluation step
        best = {'combination': [],
                'benefit_to_size_ratio': 0}

        initial_cost = self._retrieve_cost(index_combination)
        # Breaking when no cost improvement
        while True:
            single_attribute_index_candidates = self._remove_candidates_too_large_for_budget(index_combination_size, single_attribute_index_candidates)
            for candidate in single_attribute_index_candidates:
                # Only single column index generation
                if candidate not in index_combination:
                    self._evaluate_combination(index_combination + [candidate],
                                               best, initial_cost)

                # Multi column indexes are generated by attaching columns to existing indexes
                self._attach_to_indexes(index_combination, candidate, best, initial_cost)
            if best['benefit_to_size_ratio'] == 0:
                break
            index_combination = best['combination']
            best['benefit_to_size_ratio'] = 0
            index_combination_size = sum(x.estimated_size
                                         for x in index_combination)
            print(f'{index_combination} - {index_combination_size}')
            print('####')
        return index_combination

    def _attach_to_indexes(self, index_combination, candidate, best, initial_cost):
        assert candidate.is_single_column() == True

        for position, index in enumerate(index_combination):
            if index.appendable_by(candidate):
                new_combination = index_combination.copy()
                new_combination[position] = Index(index.columns +
                    candidate.columns)
                self._evaluate_combination(new_combination, best,
                    initial_cost)

    def _remove_candidates_too_large_for_budget(self, index_combination_size, candidates):
        new_candidates = []
        for candidate in candidates:
            if candidate.estimated_size is None:
                new_candidates.append(candidate)
                continue
            combined_size = candidate.estimated_size + index_combination_size
            if combined_size <= self.budget:
                new_candidates.append(candidate)

        return new_candidates

    def _evaluate_combination(self, index_combination, best,
                              initial_cost):
        cost = self._retrieve_cost(index_combination)
        benefit = initial_cost - cost
        size = sum(x.estimated_size for x in index_combination)
        ratio = benefit / size
        if ratio > best['benefit_to_size_ratio'] and size <= self.budget:
            logging.debug(f'new best cost and size: {cost}\t'
                          f'{round(size/1000000, 2)}MB')
            best['combination'] = index_combination
            best['benefit_to_size_ratio'] = ratio

    def _retrieve_cost(self, indexes):
        cost = self.cost_evaluation.calculate_cost(self.workload, indexes,
                                                   store_size=True)
        return cost

    # The cost to get to the new index combination, i.e. cost of
    # adding new indexes and dropping existing unneeded indexes
    def _retrieve_reconfig_cost(self, new, existing_indexes=[]):
        return 0
