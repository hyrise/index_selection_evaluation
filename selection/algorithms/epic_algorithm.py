from ..selection_algorithm import SelectionAlgorithm
from ..index import Index
import logging

# cost_estimation: 'whatif' or 'acutal_runtimes'
# Index combination budget in MB
<<<<<<< HEAD
DEFAULT_PARAMETERS = {
    'cost_estimation': 'whatif',
    'budget': 10,
    'min_cost_improvement': 1.01
}
=======
DEFAULT_PARAMETERS = {'cost_estimation': 'whatif', 'budget': 10, 'min_cost_improvement': 1.01, 'max_index_columns': 4}
>>>>>>> 6bfe7c8... Fix epic


class EPICAlgorithm(SelectionAlgorithm):
    def __init__(self, database_connector, parameters=None):
        if parameters is None:
            parameters = {}
        SelectionAlgorithm.__init__(self, database_connector, parameters,
                                    DEFAULT_PARAMETERS)
        # MB to Bytes
        self.budget = self.parameters['budget'] * 1000000
        self.max_index_columns = self.parameters['max_index_columns']
        self.workload = None
        self.min_cost_improvement = self.parameters['min_cost_improvement']

    def _calculate_best_indexes(self, workload):
        logging.info('Calculating best indexes EPIC')
        self.workload = workload
        single_attribute_index_candidates = self.workload.potential_indexes()

        # Current index combination
        index_combination = []
        index_combination_size = 0
        # Best index combination during evaluation step
        best = {'combination': [], 'benefit_to_size_ratio': 0, 'cost': None}

        current_cost = self.cost_evaluation.calculate_cost(self.workload,
                                                           index_combination,
                                                           store_size=True)
        self.initial_cost = current_cost
        # Breaking when no cost improvement
        while True:
            single_attribute_index_candidates = self._get_candidates_within_budget(
                index_combination_size, single_attribute_index_candidates)
            for candidate in single_attribute_index_candidates:
                # Only single column index generation
                if candidate not in index_combination:
                    self._evaluate_combination(index_combination + [candidate],
                                               best, current_cost)

                # Multi column indexes are generated by attaching columns to existing indexes
                self._attach_to_indexes(index_combination, candidate, best)
            if best['benefit_to_size_ratio'] <= 0 or (
                    best['cost'] * self.min_cost_improvement) >= current_cost:
                break
            index_combination = best['combination']
            best['benefit_to_size_ratio'] = 0
            current_cost = best['cost']
            index_combination_size = sum(index.estimated_size
                                         for index in index_combination)

        return index_combination

    def _attach_to_indexes(self, index_combination, candidate, best):
        assert candidate.is_single_column(
        ) is True, 'Attach to indexes called with multi column index'

        for position, index in enumerate(index_combination):
            if len(index.columns) >= self.max_index_columns:
                continue
            if index.appendable_by(candidate):
                new_combination = index_combination.copy()
                new_combination[position] = Index(index.columns +
                                                  candidate.columns)
                if new_combination[position] in index_combination:
                    continue
                self._evaluate_combination(new_combination, best, current_cost)

    def _get_candidates_within_budget(self, index_combination_size,
                                      candidates):
        new_candidates = []
        for candidate in candidates:
            if (candidate.estimated_size is
                    None) or (candidate.estimated_size + index_combination_size
                              <= self.budget):
                new_candidates.append(candidate)
        return new_candidates

    def _evaluate_combination(self, index_combination, best, current_cost)
        cost = self.cost_evaluation.calculate_cost(self.workload,
                                                   index_combination,
                                                   store_size=True)
        benefit = self.initial_cost - cost
        if (cost * self.min_cost_improvement) >= current_cost:
            return
        size = sum(x.estimated_size for x in index_combination)
        ratio = benefit / size
        if ratio > best['benefit_to_size_ratio'] and size <= self.budget:
            logging.debug(f'new best cost and size: {cost}\t'
                          f'{round(size/1000000, 2)}MB')
            best['combination'] = index_combination
            best['benefit_to_size_ratio'] = ratio
            best['cost'] = cost
